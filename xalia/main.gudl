/* Default UI description, language subject to change as it develops */

// Application-specific behaviors:

// APPLICATION: EA App

window (uia_class_name == "eax::services::windowing::QmlView") {
    manual_buttons: true; // buttons do not respond to uia_invoke
    manual_checkboxes: true; // checkboxes do not respond to uia_invoke

    // We don't get structure change notifications from elements.
    poll_children: true;

    descendent {
        if (recurse) {
            poll_children: true;
        }

        combo_box {
            recurse: false; // this can get all the list items which is time-consuming

            if (uia_focused) {
                root
                {
                    disable_interactions: true; // TODO: Map keyboard commands
                    poll_focus: true;
                }

            }
        }

        toolkit: "Qt";
    }
}

group (parent.(uia_control_type.custom and parent.uia_class_name == "eax::services::windowing::QmlView")) {
    // Most controls have reported coordinates offset by the height of the titlebar
    offset_target_y: parent.child_matches(uia_control_type.button).height;
}

// APPLICATION: Firefox
window (uia_class_name == "MozillaWindowClass") {
    firefox_use_offscreen_menu: true;
}

if (uia_control_type.(tool_bar or menu_bar or menu_item) and parent.firefox_use_offscreen_menu) {
    offscreen: false;
    firefox_use_offscreen_menu: true;
}

// General behaviors:

if (spi_attributes.xalia_ignore)
{
    recurse: false;
    stop: true;
}

// If a menu is open, we shouldn't try to interact with anything else.
menu (child_matches(spi_state.showing) and (not parent.spi_role.(menu or combo_box) or child_matches(spi_state.selected)))
{
    root
    {
        disable_interactions: true;
    }

    // Find the deepest menu that is showing and has an item selected, or
    // the top-level menu if there is no item selected.
    if (not child_matches(spi_role.menu and spi_state.selected and child_matches(spi_state.selected)))
    {
        // Use keyboard interaction for this if possible, it's probably less janky than going through AT-SPI
        action_on_dpad_up: send_key.up or
            child_matches(spi_state.selected).previous_sibling_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select or
            last_child_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select;
        action_on_dpad_down: send_key.down or
            child_matches(spi_state.selected).next_sibling_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select or
            first_child_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select;

        // Open a menu if possible, otherwise go to the "next" menu
        action_on_dpad_right: send_key.right or
            child_matches(spi_state.selected and spi_role.menu).spi_action.click or
            ancestor_matches(spi_role.menu_bar).child_matches(spi_state.selected).(
                next_sibling_matches(sensitive and visible and showing) or
                first_sibling_matches(sensitive and visible and showing)
            ).spi_action.click;
        // We can't really hide a menu, but we can deselect its child which (based on the
        // logic above) will mean we no longer treat it as open, and will hide its children.
        action_on_dpad_left: send_key.left or
            (parent.spi_role.menu and spi_clear_selection) or
            ancestor_matches(spi_role.menu_bar).child_matches(spi_state.selected).(
                previous_sibling_matches(sensitive and visible and showing) or
                last_sibling_matches(sensitive and visible and showing)
            ).spi_action.click;
        action_on_left_stick: simulate_dpad;
        action_on_A: send_key.enter or child_matches(spi_state.selected).click;
        action_name_A: "Select";
        if (parent.spi_role.menu)
        {
            action_on_B: send_key.left or spi_clear_selection;
        }
        action_on_B: send_key.escape or
            (parent.spi_role.(menu or menu_bar) and spi_deselect) or 
            root.this_or_descendent_matches(spi_role.combo_box and child_matches(spi_role.menu and spi_state.showing)).spi_action.press;
        action_name_B: "Back";
        action_on_start: send_key.escape or
            this_or_ancestor_matches(parent.spi_role.menu_bar).spi_deselect or
            root.this_or_descendent_matches(spi_role.combo_box and child_matches(spi_role.menu and spi_state.showing)).spi_action.press;
        action_name_Start: "Close Menu";
    }
}

// Qt combo boxes contain lists, not menus like in Gtk
combo_box (child_matches(spi_role.list and (spi_state.focused or child_matches(spi_state.focused))))
{
    root
    {
        disable_interactions: true;
    }

    // We can't manipulate the menu through AT-SPI, we have to use the keyboard
    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    action_name_A: "Select";
    action_on_B: send_key.esc or spi_action.Press;
    action_name_B: "Back";
    action_on_start: send_key.esc or spi_action.Press;
    action_name_start: "Close Menu";
}

combo_box (uia_expand_collapse_state.expanded) {
    root
    {
        disable_interactions: true;
    }

    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    action_name_A: "Select";
    action_on_B: uia_collapse or send_key.esc;
    action_name_B: "Back";
    action_on_start: uia_collapse or send_key.esc;
    action_name_start: "Close Menu";
}

// Qt/AT-SPI2 menus
popup_menu (spi_state.showing)
{
    root
    {
        disable_interactions: true;
    }

    // We can't manipulate the menu through AT-SPI, we have to use the keyboard
    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_dpad_left: send_key.left;
    action_on_dpad_right: send_key.right;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    action_name_A: "Select";
    action_on_B: send_key.esc or parent.spi_action.ShowMenu;
    action_name_B: "Back";
    action_on_start: send_key.esc or parent.spi_action.ShowMenu;
    action_name_start: "Close Menu";
}

// UI Automation menubars
root (win32_active_element.uia_class_name == "#32768")
{
    // Active menu, this doesn't normally happen and suggests Alt to dismiss may not work if the normal menu loop isn't used
    disable_interactions: true;

    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_dpad_left: send_key.left;
    action_on_dpad_right: send_key.right;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    action_name_A: "Select";
	action_on_B: send_key.esc;
    action_name_B: "Back";
	action_on_start: send_key.esc;
    action_name_start: "Close Menu";
}

root (uia_menu_mode or uia_in_menu or
    child_matches(uia_class_name == "Qt5QWindowPopupDropShadowSaveBits"))
{
    disable_interactions: true;

    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_dpad_left: send_key.left;
    action_on_dpad_right: send_key.right;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    // On Windows, pressing Escape hides the menu but stays in "menu mode", so we must use Alt to dismiss
    action_name_A: "Select";
    if (uia_in_submenu) {
        action_on_B: send_key.esc;
    }
    action_on_B: send_key.alt;
    action_name_B: "Back";
    action_on_start: send_key.alt;
    action_name_start: "Close Menu";
}

// Controls for targeting elements
root
{
    if (not disable_interactions)
    {
        action_on_dpad_up: target_move_up;
        action_on_dpad_down: target_move_down;
        action_on_dpad_left: target_move_left;
        action_on_dpad_right: target_move_right;
        action_on_left_stick: target_move;
    }
    action_repeat_delay_dpad_up: 500;
    action_repeat_delay_dpad_down: 500;
    action_repeat_delay_dpad_left: 500;
    action_repeat_delay_dpad_right: 500;
    action_repeat_delay_left_stick: 500;
    action_repeat_interval_dpad_up: 100;
    action_repeat_interval_dpad_down: 100;
    action_repeat_interval_dpad_left: 100;
    action_repeat_interval_dpad_right: 100;
    action_repeat_interval_left_stick: 100;
}

// Combo boxes contain subcontrols we don't want to directly navigate to
if (parent.combo_box and not uia_expand_collapse_state.leaf_node)
{
    interactable: false;
}

// We have a separate mechanism for interacting with menus
if (parent.menu)
{
    interactable: false;
}

if (role.(desktop_frame or application)) {
    recurse: true;

    if (spi_toolkit_name == "Qt") {
        // Qt on AT-SPI2 does not notify when children of its application object are created or destroyed.
        poll_children: true;
    }
}

if (role.(window or frame or dialog or color_chooser or file_chooser or font_chooser))
{
    recurse: true;
}

// List children of containers
if (role.(filler or internal_frame or panel or html_container or
              layered_pane or option_pane or root_pane or scroll_pane or
              split_pane or table or table_cell or toolbar or
              viewport or embedded or document_frame or
              section or page or form or table_row or document_web or grouping
              or info_bar or page_tab or page_tab_list or menu_bar or menu or
              combo_box or menu_item or pane or group or document)) {
    recurse: true;
}

if (is_uia_element and uia_control_type == undefined and msaa_role.(border or client)) {
    // Origin client has a lot of elements like this
    recurse: true;
}

if (is_uia_element and uia_control_type.custom and msaa_role.(push_button or client)) {
    // EA App has container controls that look like this
    recurse: true;
}

if (is_uia_element and uia_control_type.(text or list_item) and toolkit == "Qt") {
    // In Qt web views, these can contain edit boxes
    recurse: true;
}

// Required to determine when a combo box is open in Qt
list (parent.spi_role.combo_box and spi_application.toolkit_name == "Qt")
{
    recurse: true;
}

// We normally should only consider the active window when searching for controls to interact with
if (active and not root.disable_interactions) {
    interactable: true;
}

if (uia_control_type.window) {
    // In UI Automation, "owned" windows (usually dialog boxes) are children of the "owner" window.
    // We don't want to try to interact with controls in these windows when the owner is the foreground window.
    interactable: false;
}

// We'd need an unbroken chain of enabled/visible controls from the active window to interact with
// a control through the mouse and keyboard, so normally we should only consider those. AT-SPI may
// let us do things with other controls, but it might be confusing or break applications.
if (is_spi_element and spi_state.enabled and spi_state.showing and spi_state.sensitive and
    (spi_state.visible or spi_application.toolkit_name == "Qt") and // Qt doesn't reliably set visible for some reason (or notify about it?)
    parent.interactable) {

    // Qt combo boxes have a structure like this: tool_bar(text, combo_box(list, text))
    // That is, the text is duplicated. We want to ignore the extra text box that is outside the combo_box in the tree.
    text (spi_application.toolkit_name == "Qt" and parent.spi_role.tool_bar and next_sibling.spi_role.combo_box and
        next_sibling.child_matches(text).spi_path == spi_path) {
        interactable: false;
    }

    interactable: true;
}

if (is_uia_element and parent.interactable and enabled and
    (not offscreen or (toolkit == "Qt" and ancestor_matches(uia_control_type.document)))) { // Qt web views can have offscreen client controls with visible children
    interactable: true;
}

// manual_buttons hack
if (parent.manual_buttons) {
    manual_buttons: true;
}

// manual_checkboxes hack
if (parent.manual_checkboxes) {
    manual_checkboxes: true;
}

if (uia_control_type.hyperlink and toolkit == "Qt" and ancestor_matches(uia_control_type.document)) {
	// uia_invoke doesn't seem to work for links in Qt web views
    manual_buttons: true;
}

if (parent.offset_target_x) {
    offset_target_x: parent.offset_target_x;
}

if (parent.offset_target_y) {
    offset_target_y: parent.offset_target_y;
}

// Rules for setting borders of targetable elements
if (targetable) {
    // "special" rules would go here

    if (is_spi_element) {
        // AT-SPI2 makes it practically impossible to monitor a control's position without polling. We get
        // no notification of window movement. Calling GetExtents with ATSPI_COORD_TYPE_PARENT consistently
        // gives screen coordinates. The BoundsChanged notification seems to give window-relative coordinates,
        // but it doesn't do this consistently and doesn't always fire when window-relative coordinates change.

        // If there are any specific cases where it's possible to do this better, we can add them here.

        // Absolute screen coordinates
        target_x: abs_x + (offset_target_x or 0);
        target_y: abs_y + (offset_target_y or 0);

        // For some reason, Qt often returns incorrect values when querying width or height in any
        // coordinate space other than screen. Since we're already polling for absolute position,
        // it doesn't make much sense to gate this behavior on toolkit.
        target_width: spi_abs_width;
        target_height: spi_abs_height;
    }

    if (is_uia_element) {
        target_x: x + (offset_target_x or 0);
        target_y: y + (offset_target_y or 0);
        target_width: width;
        target_height: height;
    }

    if (targeted and action_on_PrimaryAction) {
        action_on_A: action_on_PrimaryAction;
        action_name_A: action_name_PrimaryAction;
    }
}

// Rules that apply to controls in the active window
if (interactable) {
    combo_box (not uia_expand_collapse_state.leaf_node) {
        targetable: true;

        action_on_PrimaryAction: spi_action.(press or Press) or uia_expand or uia_invoke or msaa_do_default_action;
        action_name_PrimaryAction: "Select";

        if (targeted) {
            child (text_box) {
                action_on_Y: set_focus+show_keyboard;
                action_name_Y: "Show Keyboard";
            }

            action_on_right_stick: simulate_dpad("rs");
            action_name_right_stick: "Scroll";
            action_on_rs_up: set_focus+send_key.up;
            action_on_rs_down: set_focus+send_key.down;
        }
    }

    // Direct control interaction
    if (is_spi_element and menu) {
        targetable: true;

        action_on_PrimaryAction: spi_action.click;
        action_name_PrimaryAction: "Click";
    }

    // Qt/AT-SPI2 does its menu bars this way
    menu_item (parent.spi_role.menu_bar and spi_action.ShowMenu)
    {
        targetable: true;

        action_on_PrimaryAction: spi_action.ShowMenu;
        action_name_PrimaryAction: "Click";
    }

    // UI Automation menu
    menu_item (is_uia_element and parent.menu_bar)
    {
        targetable: true;

        action_on_PrimaryAction: uia_invoke or msaa_do_default_action;
        action_name_PrimaryAction: "Click";
    }

    page_tab {
        targetable: true;
        action_on_PrimaryAction: spi_action.Press or select;
        action_name_PrimaryAction: "Select Tab";
    }

    if (uia_control_type.image and uia_is_keyboard_focusable) {
        targetable: true;
        action_on_PrimaryAction: send_click;
        action_name_PrimaryAction: "Click";
    }

    if ((spi_role.button or spi_role.radio_button) and spi_action.(click or Press or Toggle)) {
        targetable: true;
        action_on_PrimaryAction: spi_action.(click or Press or Toggle);
        action_name_PrimaryAction: "Click";
    }

    if (uia_control_type.(button or radio_button or hyperlink)) {
        targetable: true;
        if (manual_buttons)  {
			action_on_PrimaryAction: send_click;
        }
        action_on_PrimaryAction: uia_invoke or msaa_do_default_action or send_click;
        action_name_PrimaryAction: "Click";
    }

    check_box (manual_checkboxes) {
        targetable: true;
        action_on_PrimaryAction: send_click;
        action_name_PrimaryAction: "Toggle";
    }

    check_box (spi_action.(click or Toggle or Press)) {
        targetable: true;
        action_on_PrimaryAction: spi_action.(click or Toggle or Press);
        action_name_PrimaryAction: "Toggle";
    }

    if (uia_control_type.check_box) {
        targetable: true;
        action_on_PrimaryAction: uia_invoke or msaa_do_default_action;
        action_name_PrimaryAction: "Toggle";
    }

    if ((is_spi_element and spi_role.text) or (is_uia_element and (uia_control_type.edit or
        (uia_control_type.document and not first_child)))) { // Qt web controls show up as document but aren't really editable
        targetable: true;
		if (is_uia_element and acc2_toolkit_name == "Qt" and ancestor_matches(uia_control_type.document)) {
			// set_focus doesn't seem to work for Qt web views
			action_on_PrimaryAction: send_click+show_keyboard;
		}
		action_on_PrimaryAction: set_focus+show_keyboard;
		action_name_PrimaryAction: "Show Keyboard";
    }

    // Tab bar navigation

    // GTK2: Sometimes the initially selected tab does not have the selected state.
    page_tab (spi_application.toolkit_name == "GAIL" and child_matches(spi_state.showing)) {
        selected: true;
    }

    // Qt/AT-SPI2: The selected state is not set, but we can infer it using the sibling layered_pane
    page_tab (spi_application.toolkit_name == "Qt" and
        parent.spi_role.page_tab_list and
        parent.parent.spi_role.filler and
        parent.first_sibling.spi_role.layered_pane and
        parent.first_sibling.child_at_index(index_in_parent).spi_state.showing) {
        selected: true;
    }

    page_tab (previous_sibling_matches(interactable).(page_tab and selected)) {
        action_on_RB: action_on_PrimaryAction;
        action_name_RB: spi_name;
    }
    page_tab (next_sibling_matches(interactable).(page_tab and selected)) {
        action_on_LB: action_on_PrimaryAction;
        action_name_LB: spi_name;
    }

    menu_bar (child_matches(action_on_PrimaryAction))
    {
        action_on_start: child_matches(action_on_PrimaryAction).action_on_PrimaryAction;
        action_name_start: "Open Menu";
    }

    button ((name == "OK" or name == "Run" or name == "Play" or name == "PLAY" or name == "Yes") and action_on_PrimaryAction)
    {
        action_on_start: action_on_PrimaryAction;
        action_name_start: name;
    }

    button ((name == "Cancel" or name == "Close" or name == "No") and action_on_PrimaryAction)
    {
        action_on_B: action_on_PrimaryAction;
        action_name_B: name;
    }
}
