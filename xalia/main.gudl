/* Default UI description, language subject to change as it develops */

if (spi_attributes.xalia_ignore)
{
    recurse: false;
    stop: true;
}

// If a menu is open, we shouldn't try to interact with anything else.
menu (child_matches(spi_state.showing) and (not parent.spi_role.(menu or combo_box) or child_matches(spi_state.selected)))
{
    root
    {
        disable_interactions: true;
    }

    // Find the deepest menu that is showing and has an item selected, or
    // the top-level menu if there is no item selected.
    if (not child_matches(spi_role.menu and spi_state.selected and child_matches(spi_state.selected)))
    {
        // Use keyboard interaction for this if possible, it's probably less janky than going through AT-SPI
        action_on_dpad_up: send_key.up or
            child_matches(spi_state.selected).previous_sibling_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select or
            last_child_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select;
        action_on_dpad_down: send_key.down or
            child_matches(spi_state.selected).next_sibling_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select or
            first_child_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select;

        // Open a menu if possible, otherwise go to the "next" menu
        action_on_dpad_right: send_key.right or
            child_matches(spi_state.selected and spi_role.menu).spi_action.click or
            ancestor_matches(spi_role.menu_bar).child_matches(spi_state.selected).(
                next_sibling_matches(sensitive and visible and showing) or
                first_sibling_matches(sensitive and visible and showing)
            ).spi_action.click;
        // We can't really hide a menu, but we can deselect its child which (based on the
        // logic above) will mean we no longer treat it as open, and will hide its children.
        action_on_dpad_left: send_key.left or
            (parent.spi_role.menu and spi_clear_selection) or
            ancestor_matches(spi_role.menu_bar).child_matches(spi_state.selected).(
                previous_sibling_matches(sensitive and visible and showing) or
                last_sibling_matches(sensitive and visible and showing)
            ).spi_action.click;
        action_on_left_stick: simulate_dpad;
        action_on_A: send_key.enter or child_matches(spi_state.selected).click;
        action_name_A: "Select";
        if (parent.spi_role.menu)
        {
            action_on_B: send_key.left or spi_clear_selection;
        }
        action_on_B: send_key.escape or
            (parent.spi_role.(menu or menu_bar) and spi_deselect) or 
            root.this_or_descendent_matches(spi_role.combo_box and child_matches(spi_role.menu and spi_state.showing)).spi_action.press;
        action_name_B: "Back";
        action_on_start: send_key.escape or
            this_or_ancestor_matches(parent.spi_role.menu_bar).spi_deselect or
            root.this_or_descendent_matches(spi_role.combo_box and child_matches(spi_role.menu and spi_state.showing)).spi_action.press;
        action_name_Start: "Close Menu";
    }
}

// Qt combo boxes contain lists, not menus like in Gtk
combo_box (child_matches(spi_role.list and (spi_state.focused or child_matches(spi_state.focused))))
{
    root
    {
        disable_interactions: true;
    }

    // We can't manipulate the menu through AT-SPI, we have to use the keyboard
    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    action_name_A: "Select";
    action_on_B: send_key.esc or spi_action.Press;
    action_name_B: "Back";
    action_on_Start: send_key.esc or spi_action.Press;
    action_name_Start: "Close Menu";
}

// Controls for targeting elements
root
{
    if (not disable_interactions)
    {
        action_on_dpad_up: target_move_up;
        action_on_dpad_down: target_move_down;
        action_on_dpad_left: target_move_left;
        action_on_dpad_right: target_move_right;
        action_on_left_stick: target_move;
    }
    action_repeat_delay_dpad_up: 500;
    action_repeat_delay_dpad_down: 500;
    action_repeat_delay_dpad_left: 500;
    action_repeat_delay_dpad_right: 500;
    action_repeat_delay_left_stick: 500;
    action_repeat_interval_dpad_up: 100;
    action_repeat_interval_dpad_down: 100;
    action_repeat_interval_dpad_left: 100;
    action_repeat_interval_dpad_right: 100;
    action_repeat_interval_left_stick: 100;
}

// Combo boxes contain subcontrols we don't want to directly navigate to
if (parent.spi_role.combo_box)
{
    interactable: false;
}

// We have a separate mechanism for interacting with menus
if (parent.spi_role.menu)
{
    interactable: false;
}

if (spi_role.(desktop_frame or application)) {
    recurse: true;

    if (spi_toolkit_name == "Qt") {
        // Qt on AT-SPI2 does not notify when children of its application object are created or destroyed.
        poll_children: true;
    }
}

if (spi_role.(window or frame or dialog or color_chooser or file_chooser or font_chooser))
{
    recurse: true;
}

// List children of containers
if (spi_role.(filler or internal_frame or panel or html_container or
              layered_pane or option_pane or root_pane or scroll_pane or
              split_pane or table or table_cell or toolbar or
              viewport or embedded or document_frame or
              section or page or form or table_row or document_web or grouping
              or info_bar or page_tab or page_tab_list or menu_bar or menu or combo_box)) {
    recurse: true;
}

// Required to determine when a combo box is open in Qt
list (parent.spi_role.combo_box and spi_application.toolkit_name == "Qt")
{
    recurse: true;
}

// We normally should only consider the active window when searching for controls to interact with
if (spi_state.active and not root.disable_interactions) {
    interactable: true;
}

// We'd need an unbroken chain of enabled/visible controls from the active window to interact with
// a control through the mouse and keyboard, so normally we should only consider those. AT-SPI may
// let us do things with other controls, but it might be confusing or break applications.
if (spi_state.enabled and spi_state.showing and spi_state.sensitive and
    (spi_state.visible or spi_application.toolkit_name == "Qt") and // Qt doesn't reliably set visible for some reason
    parent.interactable) {

    // Qt combo boxes have a structure like this: tool_bar(text, combo_box(list, text))
    // That is, the text is duplicated. We want to ignore the extra text box that is outside the combo_box in the tree.
    text (spi_application.toolkit_name == "Qt" and parent.spi_role.tool_bar and next_sibling.spi_role.combo_box and
        next_sibling.child_matches(text).spi_path == spi_path) {
        interactable: false;
    }

    interactable: true;
}

// Rules for setting borders of targetable objects
if (targetable) {
    // "special" rules would go here

    // AT-SPI2 makes it practically impossible to monitor a control's position without polling. We get
    // no notification of window movement. Calling GetExtents with ATSPI_COORD_TYPE_PARENT consistently
    // gives screen coordinates. The BoundsChanged notification seems to give window-relative coordinates,
    // but it doesn't do this consistently and doesn't always fire when window-relative coordinates change.

    // If there are any specific cases where it's possible to do this better, we can add them here.

    // Absolute screen coordinates
    target_x: abs_x;
    target_y: abs_y;

    // For some reason, Qt often returns incorrect values when querying width or height in any
    // coordinate space other than screen. Since we're already polling for absolute position,
    // it doesn't make much sense to gate this behavior on toolkit.
    target_width: spi_abs_width;
    target_height: spi_abs_height;
}

// Rules that apply to controls in the active window
if (interactable) {
    combo_box {
        targetable: true;

        action_on_PrimaryAction: spi_action.(press or Press);
        action_name_PrimaryAction: "Select";

        if (targeted) {
            action_on_A: action_on_PrimaryAction;
            action_name_A: action_name_PrimaryAction;
            child (spi_role.text) {
                action_on_Y: set_focus+show_keyboard;
                action_name_Y: "Show Keyboard";
            }
        }
    }

    // Direct control interaction
    menu {
        targetable: true;
        if (targeted)
        {
            action_on_A: spi_action.click;
            action_name_A: "Click";
        }
    }
    page_tab {
        targetable: true;
        if (targeted)
        {
            action_on_A: spi_select;
            action_name_A: "Change Tab";
        }
    }
    if ((spi_role.button or spi_role.radio_button) and spi_action.click) {
        targetable: true;
        if (targeted)
        {
            action_on_A: spi_action.click;
            action_name_A: "Click";
        }
    }
    check_box (spi_action.click) {
        targetable: true;
        if (targeted)
        {
            action_on_A: spi_action.click;
            action_name_A: "Toggle";
        }
    }
    text {
        targetable: true;
        if (targeted)
        {
            action_on_A: set_focus+show_keyboard;
            action_name_A: "Show Keyboard";
        }
    }

    // Tab bar navigation
    page_tab (previous_sibling_matches(interactable).(spi_state.selected or child_matches(spi_state.showing))) {
        action_on_RB: spi_select;
        action_name_RB: spi_name;
    }
    page_tab (next_sibling_matches(interactable).(spi_state.selected or child_matches(spi_state.showing))) {
        action_on_LB: spi_select;
        action_name_LB: spi_name;
    }

    menu_bar
    {
        action_on_start: first_child.spi_action.click;
        action_name_start: "Open Menu";
    }

    button ((spi_name == "OK" or spi_name == "Run" or spi_name == "Play" or spi_name == "PLAY" or spi_name == "Yes") and spi_action.click)
    {
        action_on_start: spi_action.click;
        action_name_start: spi_name;
    }

    button ((spi_name == "Cancel" or spi_name == "Close" or spi_name == "No") and spi_action.click)
    {
        action_on_B: spi_action.click;
        action_name_B: spi_name;
    }
}
