/* Default UI description, language subject to change as it develops */

if (spi_attributes.xalia_ignore)
{
    recurse: false;
    stop: true;
}

// If a menu is open, we shouldn't try to interact with anything else.
menu (child_matches(spi_state.showing) and (not parent.spi_role.(menu or combo_box) or child_matches(spi_state.selected)))
{
    root
    {
        disable_interactions: true;
    }

    // Find the deepest menu that is showing and has an item selected, or
    // the top-level menu if there is no item selected.
    if (not child_matches(spi_role.menu and spi_state.selected and child_matches(spi_state.selected)))
    {
        // Use keyboard interaction for this if possible, it's probably less janky than going through AT-SPI
        action_on_dpad_up: send_key.up or
            child_matches(spi_state.selected).previous_sibling_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select or
            last_child_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select;
        action_on_dpad_down: send_key.down or
            child_matches(spi_state.selected).next_sibling_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select or
            first_child_matches(spi_state.(sensitive and visible and showing) and spi_role.(menu or menu_item or check_menu_item or radio_menu_item)).spi_select;

        // Open a menu if possible, otherwise go to the "next" menu
        action_on_dpad_right: send_key.right or
            child_matches(spi_state.selected and spi_role.menu).spi_action.click or
            ancestor_matches(spi_role.menu_bar).child_matches(spi_state.selected).(
                next_sibling_matches(sensitive and visible and showing) or
                first_sibling_matches(sensitive and visible and showing)
            ).spi_action.click;
        // We can't really hide a menu, but we can deselect its child which (based on the
        // logic above) will mean we no longer treat it as open, and will hide its children.
        action_on_dpad_left: send_key.left or
            (parent.spi_role.menu and spi_clear_selection) or
            ancestor_matches(spi_role.menu_bar).child_matches(spi_state.selected).(
                previous_sibling_matches(sensitive and visible and showing) or
                last_sibling_matches(sensitive and visible and showing)
            ).spi_action.click;
        action_on_left_stick: simulate_dpad;
        action_on_A: send_key.enter or child_matches(spi_state.selected).click;
        action_name_A: "Select";
        if (parent.spi_role.menu)
        {
            action_on_B: send_key.left or spi_clear_selection;
        }
        action_on_B: send_key.escape or
            (parent.spi_role.(menu or menu_bar) and spi_deselect) or 
            root.this_or_descendent_matches(spi_role.combo_box and child_matches(spi_role.menu and spi_state.showing)).spi_action.press;
        action_name_B: "Back";
        action_on_start: send_key.escape or
            this_or_ancestor_matches(parent.spi_role.menu_bar).spi_deselect or
            root.this_or_descendent_matches(spi_role.combo_box and child_matches(spi_role.menu and spi_state.showing)).spi_action.press;
        action_name_Start: "Close Menu";
    }
}

// Qt combo boxes contain lists, not menus like in Gtk
combo_box (child_matches(spi_role.list and (spi_state.focused or child_matches(spi_state.focused))))
{
    root
    {
        disable_interactions: true;
    }

    // We can't manipulate the menu through AT-SPI, we have to use the keyboard
    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    action_name_A: "Select";
    action_on_B: send_key.esc or spi_action.Press;
    action_name_B: "Back";
    action_on_start: send_key.esc or spi_action.Press;
    action_name_start: "Close Menu";
}

// Qt/AT-SPI2 menus
popup_menu (spi_state.showing)
{
    root
    {
        disable_interactions: true;
    }

    // We can't manipulate the menu through AT-SPI, we have to use the keyboard
    action_on_dpad_up: send_key.up;
    action_on_dpad_down: send_key.down;
    action_on_dpad_left: send_key.left;
    action_on_dpad_right: send_key.right;
    action_on_left_stick: simulate_dpad;
    action_on_A: send_key.enter;
    action_name_A: "Select";
    action_on_B: send_key.esc or parent.spi_action.ShowMenu;
    action_name_B: "Back";
    action_on_start: send_key.esc or parent.spi_action.ShowMenu;
    action_name_start: "Close Menu";
}

// Controls for targeting elements
root
{
    if (not disable_interactions)
    {
        action_on_dpad_up: target_move_up;
        action_on_dpad_down: target_move_down;
        action_on_dpad_left: target_move_left;
        action_on_dpad_right: target_move_right;
        action_on_left_stick: target_move;
    }
    action_repeat_delay_dpad_up: 500;
    action_repeat_delay_dpad_down: 500;
    action_repeat_delay_dpad_left: 500;
    action_repeat_delay_dpad_right: 500;
    action_repeat_delay_left_stick: 500;
    action_repeat_interval_dpad_up: 100;
    action_repeat_interval_dpad_down: 100;
    action_repeat_interval_dpad_left: 100;
    action_repeat_interval_dpad_right: 100;
    action_repeat_interval_left_stick: 100;
}

// Combo boxes contain subcontrols we don't want to directly navigate to
if (parent.combo_box)
{
    interactable: false;
}

// We have a separate mechanism for interacting with menus
if (parent.menu)
{
    interactable: false;
}

if (role.(desktop_frame or application)) {
    recurse: true;

    if (spi_toolkit_name == "Qt") {
        // Qt on AT-SPI2 does not notify when children of its application object are created or destroyed.
        poll_children: true;
    }
}

if (role.(window or frame or dialog or color_chooser or file_chooser or font_chooser))
{
    recurse: true;
}

// List children of containers
if (role.(filler or internal_frame or panel or html_container or
              layered_pane or option_pane or root_pane or scroll_pane or
              split_pane or table or table_cell or toolbar or
              viewport or embedded or document_frame or
              section or page or form or table_row or document_web or grouping
              or info_bar or page_tab or page_tab_list or menu_bar or menu or
              combo_box or menu_item or pane)) {
    recurse: true;
}

// Required to determine when a combo box is open in Qt
list (parent.spi_role.combo_box and spi_application.toolkit_name == "Qt")
{
    recurse: true;
}

// We normally should only consider the active window when searching for controls to interact with
if (spi_state.active and not root.disable_interactions) {
    interactable: true;
}

// We can't get the active window from UIAutomation, so we have to look for a window with a focused descendent
if (is_uia_element and parent.desktop_frame and (this == uia_focused_element or is_ancestor_of(uia_focused_element))) {
    interactable: true;
}

// We'd need an unbroken chain of enabled/visible controls from the active window to interact with
// a control through the mouse and keyboard, so normally we should only consider those. AT-SPI may
// let us do things with other controls, but it might be confusing or break applications.
if (is_spi_element and spi_state.enabled and spi_state.showing and spi_state.sensitive and
    (spi_state.visible or spi_application.toolkit_name == "Qt") and // Qt doesn't reliably set visible for some reason (or notify about it?)
    parent.interactable) {

    // Qt combo boxes have a structure like this: tool_bar(text, combo_box(list, text))
    // That is, the text is duplicated. We want to ignore the extra text box that is outside the combo_box in the tree.
    text (spi_application.toolkit_name == "Qt" and parent.spi_role.tool_bar and next_sibling.spi_role.combo_box and
        next_sibling.child_matches(text).spi_path == spi_path) {
        interactable: false;
    }

    interactable: true;
}

if (is_uia_element and parent.interactable and enabled) {
    interactable: true;
}

// Rules for setting borders of targetable elements
if (targetable) {
    // "special" rules would go here

    if (is_spi_element) {
        // AT-SPI2 makes it practically impossible to monitor a control's position without polling. We get
        // no notification of window movement. Calling GetExtents with ATSPI_COORD_TYPE_PARENT consistently
        // gives screen coordinates. The BoundsChanged notification seems to give window-relative coordinates,
        // but it doesn't do this consistently and doesn't always fire when window-relative coordinates change.

        // If there are any specific cases where it's possible to do this better, we can add them here.

        // Absolute screen coordinates
        target_x: abs_x;
        target_y: abs_y;

        // For some reason, Qt often returns incorrect values when querying width or height in any
        // coordinate space other than screen. Since we're already polling for absolute position,
        // it doesn't make much sense to gate this behavior on toolkit.
        target_width: spi_abs_width;
        target_height: spi_abs_height;
    }

    if (is_uia_element) {
        target_x: x;
        target_y: y;
        target_width: width;
        target_height: height;
    }

    if (targeted and action_on_PrimaryAction) {
        action_on_A: action_on_PrimaryAction;
        action_name_A: action_name_PrimaryAction;
    }
}

// Rules that apply to controls in the active window
if (interactable) {
    combo_box {
        targetable: true;

        action_on_PrimaryAction: spi_action.(press or Press);
        action_name_PrimaryAction: "Select";

        if (targeted) {
            child (spi_role.text) {
                action_on_Y: set_focus+show_keyboard;
                action_name_Y: "Show Keyboard";
            }
        }
    }

    // Direct control interaction
    menu {
        targetable: true;

        action_on_PrimaryAction: spi_action.click;
        action_name_PrimaryAction: "Click";
    }

    // Qt/AT-SPI2 does its menu bars this way
    menu_item (parent.spi_role.menu_bar and spi_action.ShowMenu)
    {
        targetable: true;

        action_on_PrimaryAction: spi_action.ShowMenu;
        action_name_PrimaryAction: "Click";
    }

    page_tab {
        targetable: true;
        action_on_PrimaryAction: spi_action.Press or spi_select;
        action_name_PrimaryAction: "Select Tab";
    }

    if ((spi_role.button or spi_role.radio_button) and spi_action.(click or Press or Toggle)) {
        targetable: true;
        action_on_PrimaryAction: spi_action.(click or Press or Toggle);
        action_name_PrimaryAction: "Click";
    }
    check_box (spi_action.(click or Toggle or Press)) {
        targetable: true;
        action_on_PrimaryAction: spi_action.(click or Toggle or Press);
        action_name_PrimaryAction: "Toggle";
    }
    text {
        targetable: true;
        if (targeted)
        {
            action_on_A: set_focus+show_keyboard;
            action_name_A: "Show Keyboard";
        }
    }

    // Tab bar navigation

    // Qt/AT-SPI2: It's not possible to determine which tab is active so this won't work.
    page_tab (previous_sibling_matches(interactable).(spi_state.selected or child_matches(spi_state.showing))) {
        action_on_RB: action_on_PrimaryAction;
        action_name_RB: spi_name;
    }
    page_tab (next_sibling_matches(interactable).(spi_state.selected or child_matches(spi_state.showing))) {
        action_on_LB: action_on_PrimaryAction;
        action_name_LB: spi_name;
    }

    menu_bar (child_matches(action_on_PrimaryAction))
    {
        action_on_start: child_matches(action_on_PrimaryAction).action_on_PrimaryAction;
        action_name_start: "Open Menu";
    }

    button ((spi_name == "OK" or spi_name == "Run" or spi_name == "Play" or spi_name == "PLAY" or spi_name == "Yes") and action_on_PrimaryAction)
    {
        action_on_start: action_on_PrimaryAction;
        action_name_start: spi_name;
    }

    button ((spi_name == "Cancel" or spi_name == "Close" or spi_name == "No") and action_on_PrimaryAction)
    {
        action_on_B: action_on_PrimaryAction;
        action_name_B: spi_name;
    }
}
